<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gerador de Arte — Alerta + Manchete (Overlay fixa)</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Roboto:ital,wght@0,700;1,700&family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#0b0b0c; --panel:#121316; --ink:#eaeaea; --muted:#9aa3ad; --brand:#ffd400; }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0d0f13,#0b0b0c);color:var(--ink);font-family:"Poppins",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:20px 24px 8px;display:flex;align-items:center;gap:12px}
    header h1{font-size:18px;margin:0;font-weight:800;letter-spacing:.2px}
    .app{display:grid;grid-template-columns:380px 1fr;gap:18px;padding:0 24px 24px}
    @media (max-width: 980px){ .app{grid-template-columns:1fr} }
    .panel{background:var(--panel);border:1px solid #23262d;border-radius:16px;padding:16px 14px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .panel h2{margin:4px 6px 12px;font-size:14px;color:var(--muted);font-weight:600;text-transform:uppercase;letter-spacing:.12em}
    label{display:block;font-size:12px;color:var(--muted);margin:10px 6px 6px}
    input[type="text"], textarea{width:100%;border:1px solid #2a2f39;background:#0e1116;color:var(--ink);border-radius:10px;padding:10px 12px;font-size:14px;outline:none}
    input[type="file"]{width:100%}
    textarea{min-height:110px;resize:vertical}
    .row{display:flex;gap:10px;align-items:center}
    .row > *{flex:1}
    .btns{display:flex;gap:10px;margin-top:12px;flex-wrap:wrap}
    button{background:#1f2937;color:#f7fbff;border:1px solid #2a2f39;border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.primary{background:var(--brand);color:#151515;border-color:#d6b700}
    button:disabled{opacity:.5;cursor:not-allowed}
    .stage{background:#0b0c0e;border:1px solid #23262d;border-radius:16px;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:16px;gap:12px}
    .stage .canvas-wrap{position:relative;border-radius:12px;overflow:hidden;background:#111}
    .ghost{font-size:13px;color:#9199a6}
    .note{font-size:12px;color:#8892a0}
    code{background:#0e1116;border:1px solid #2a2f39;border-radius:6px;padding:2px 6px}
  </style>
</head>
<body>
  <header>
    <svg width="26" height="26" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><circle cx="12" cy="12" r="11" stroke="#ffd400" stroke-width="2"/><path d="M12 6.5V13M12 17.5h.01" stroke="#ffd400" stroke-width="2" stroke-linecap="round"/></svg>
    <h1>Gerador de Arte — Alerta + Manchete (Overlay fixa)</h1>
  </header>

  <div class="app">
    <section class="panel">
      <h2>Conteúdo</h2>

      <!-- ORDEM: Foto de Fundo → Editoria → Manchete -->
      <label for="upload">Foto de fundo</label>
      <input id="upload" type="file" accept="image/*" />

      <label for="destaque">Editoria</label>
      <input id="destaque" type="text" placeholder="URGENTE" value="URGENTE" />

      <label for="manchete">Manchete</label>
      <textarea id="manchete" placeholder="Digite a manchete..."></textarea>

      <div class="btns">
        <button id="download" class="primary" disabled>Baixar imagem</button>
      </div>
    </section>

    <section class="stage">
      <div class="canvas-wrap">
        <canvas id="canvas" width="1080" height="1350" style="width: 420px; height: auto; max-width: 100%; touch-action: none;"></canvas>
      </div>
      <div class="ghost">Dica: arraste para reposicionar a foto.</div>
    </section>
  </div>

  <script>
    // ===== Configuração rápida =====
    // BOTTOM_MARGIN: distância da ÚLTIMA linha de texto até a borda inferior
    // GAP_BETWEEN_BOX_AND_TEXT: distância do FUNDO do box amarelo até o TOPO visual da 1ª linha
    const CONFIG = {
      BOTTOM_MARGIN: 120,
      GAP_BETWEEN_BOX_AND_TEXT: 36 // mantido como sua versão atual salva
    };

    const $ = (q) => document.querySelector(q);
    const canvas = $('#canvas');
    let ctx = canvas.getContext('2d'); // será escalado por DPR em cada render

    const els = {
      destaque: $('#destaque'),
      manchete: $('#manchete'),
      upload:   $('#upload'),
      download: $('#download'),
      clear:    $('#clear')
    };

    // --- Garantir que as fontes carregaram antes de desenhar no Canvas ---
    let fontsLoaded = false;
    async function ensureFonts(){
      if(fontsLoaded) return;
      try{
        await Promise.all([
          document.fonts.load('400 64px "Bebas Neue"'),
          document.fonts.load('700 italic 64px "Roboto"'),
          document.fonts.ready
        ]);
      }catch(e){ /* ignore */ }
      fontsLoaded = true;
    }

    // Overlay fixa (arquivo em /public/overlay.png)
    const OVERLAY_SRC = 'overlay.png';

    // ===== Estado da imagem de fundo + drag =====
    let bgURL = null;
    let bgImg = null; // Image()
    const bgState = {
      // dimensões escaladas para "cover"
      dw: 0, dh: 0,
      // posição atual (top-left) dentro do canvas lógico 1080x1350
      x: 0, y: 0,
      // limites para arrastar (x e y entre min e max)
      minX: 0, maxX: 0,
      minY: 0, maxY: 0
    };

    function revokeBgURL(){
      if(bgURL){ URL.revokeObjectURL(bgURL); bgURL = null; }
    }

    function computeCoverDims(img, W, H){
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      const scale = Math.max(W / iw, H / ih);
      return { dw: Math.ceil(iw * scale), dh: Math.ceil(ih * scale) };
    }

    function centerAndClampBg(W, H){
      // centraliza inicialmente e calcula limites
      if(!bgImg) return;
      const { dw, dh } = computeCoverDims(bgImg, W, H);
      bgState.dw = dw; bgState.dh = dh;

      // posição central
      bgState.x = Math.floor((W - dw) / 2);
      bgState.y = Math.floor((H - dh) / 2);

      // limites (se a imagem for menor/equal em algum eixo, trava no centro)
      if (dw > W) { bgState.minX = W - dw; bgState.maxX = 0; }
      else        { bgState.minX = bgState.maxX = bgState.x; }

      if (dh > H) { bgState.minY = H - dh; bgState.maxY = 0; }
      else        { bgState.minY = bgState.maxY = bgState.y; }
    }

    function clamp(val, min, max){ return Math.min(max, Math.max(min, val)); }

    // ===== Helpers =====
    function wrapText(text, maxWidth){
      const words = (text||'').split(/\s+/); let line = '', lines=[];
      for(const w of words){
        const test = line ? line + ' ' + w : w;
        const m = ctx.measureText(test).width;
        if(m > maxWidth && line){ lines.push(line); line = w; }
        else line = test;
      }
      if(line) lines.push(line);
      return lines;
    }

    function loadImage(url){
      return new Promise((res)=>{ 
        if(!url) return res(null); 
        const img=new Image(); 
        img.onload=()=>res(img); 
        img.onerror=()=>res(null); 
        img.src=url; 
      });
    }

    // Helpers para medir/desenhar com letter-spacing
    function textWidthWithSpacing(ctx, text, spacing){
      let w = 0; 
      for(let i=0;i<text.length;i++){ 
        const ch = text[i]; 
        w += ctx.measureText(ch).width; 
        if(i < text.length-1) w += spacing; 
      } 
      return w;
    }
    function fillTextWithSpacing(ctx, text, x, y, spacing){
      let dx = x; 
      for(let i=0;i<text.length;i++){ 
        const ch = text[i]; 
        ctx.fillText(ch, dx, y); 
        dx += ctx.measureText(ch).width + (i < text.length-1 ? spacing : 0); 
      }
    }

    async function render(){
      await ensureFonts();

      // Canvas lógico
      const W = 1080, H = 1350;

      // DPR/HiDPI
      const dpr = window.devicePixelRatio || 1;
      canvas.width = W * dpr;
      canvas.height = H * dpr;

      ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // escala tudo
      ctx.clearRect(0,0,W,H);

      // 1) Fundo (cover com reposicionamento por drag)
      if(bgImg){
        // garante que temos dw/dh/limites coerentes (caso mude o DPR/zoom de página)
        if(!bgState.dw || !bgState.dh){
          centerAndClampBg(W, H);
        }
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(bgImg, bgState.x, bgState.y, bgState.dw, bgState.dh);
      } else {
        ctx.fillStyle = '#333'; ctx.fillRect(0,0,W,H);
        ctx.fillStyle = '#777'; ctx.font = '600 28px Poppins'; ctx.fillText('Envie uma foto de fundo', 28, 48);
      }

      // 2) Overlay fixa
      const ov = await loadImage(OVERLAY_SRC);
      if(ov) ctx.drawImage(ov, 0, 0, W, H);

      // 3) Textos
      const brand = '#FFD400';

      // === Manchete: preparar medidas primeiro ===
      const headline = (els.manchete.value || '');
      const HEADLINE_FONT_SIZE = 64; // px
      const HEADLINE_LEFT_PADDING = 80; // px
      const HEADLINE_RIGHT_PADDING = 80; // px
      const LINE_HEIGHT = Math.round(HEADLINE_FONT_SIZE * 1.24);
      ctx.fillStyle = '#fff';
      ctx.font = `700 italic ${HEADLINE_FONT_SIZE}px Roboto, system-ui, sans-serif`;
      ctx.textBaseline = 'alphabetic';

      const allLines = wrapText(headline, W - HEADLINE_LEFT_PADDING - HEADLINE_RIGHT_PADDING);
      const lines = allLines.slice(0, 6);
      const L = Math.max(1, lines.length);

      // âncora do bloco pela base: última linha a BOTTOM_MARGIN px da margem inferior
      const yFirstBaseline = H - CONFIG.BOTTOM_MARGIN - (L - 1) * LINE_HEIGHT;

      // === Box amarelo (acima da manchete), colado na esquerda (x=0) ===
      let badgeText = (els.destaque.value || '').toUpperCase().normalize('NFC');

      // Configurações do badge
      const BADGE_FONT_SIZE = 64;              // px (Bebas)
      const BADGE_HEIGHT = 80;                 // altura fixa do box amarelo
      const BADGE_LETTER_SPACING = 4;          // espaçamento entre letras (px)
      const BADGE_LEFT_PADDING = 80;           // padding à esquerda do texto
      const BADGE_RIGHT_PADDING = 20;
      const OPTICAL_NUDGE_Y = 0;               // ajuste fino vertical (px)

      // Definir fonte Bebas para medir
      ctx.font = `400 ${BADGE_FONT_SIZE}px "Bebas Neue", Poppins, sans-serif`;
      ctx.textBaseline = 'alphabetic';

      // Largura do texto com espaçamento e geometria do box
      const tWidth = textWidthWithSpacing(ctx, badgeText, BADGE_LETTER_SPACING);
      const badgeW = Math.min(W, Math.max(120, tWidth + BADGE_LEFT_PADDING + BADGE_RIGHT_PADDING));
      const badgeH = BADGE_HEIGHT;

      // distância entre o box e o TOPO da primeira linha (não a baseline)
      ctx.font = `700 italic ${HEADLINE_FONT_SIZE}px Roboto, system-ui, sans-serif`;
      const mHeadline = ctx.measureText(lines[0] || 'Ag');
      const ascentHeadline = (mHeadline && mHeadline.actualBoundingBoxAscent !== undefined)
        ? mHeadline.actualBoundingBoxAscent
        : Math.round(HEADLINE_FONT_SIZE * 0.8);

      const firstLineTopY = yFirstBaseline - ascentHeadline;
      const badgeY = firstLineTopY - CONFIG.GAP_BETWEEN_BOX_AND_TEXT - badgeH;

      // Desenhar box amarelo
      ctx.fillStyle = brand;
      ctx.fillRect(0, badgeY, badgeW, badgeH);

      // Texto do badge: centralizado verticalmente pela métrica do "H" (como você pediu)
      ctx.fillStyle = '#111';
      ctx.font = `400 ${BADGE_FONT_SIZE}px "Bebas Neue", Poppins, sans-serif`;
      const refMetrics = ctx.measureText('H');
      const ascent  = refMetrics.actualBoundingBoxAscent ?? BADGE_FONT_SIZE * 0.8;
      const descent = refMetrics.actualBoundingBoxDescent ?? BADGE_FONT_SIZE * 0.2;
      const baselineY = Math.round(badgeY + (badgeH + ascent - descent)/2 + OPTICAL_NUDGE_Y);
      const textX = BADGE_LEFT_PADDING;
      fillTextWithSpacing(ctx, badgeText, textX, baselineY, BADGE_LETTER_SPACING);

      // === Desenhar a manchete (em branco), abaixo do box ===
      ctx.fillStyle = '#fff';
      ctx.font = `700 italic ${HEADLINE_FONT_SIZE}px Roboto, system-ui, sans-serif`;
      let y = yFirstBaseline;
      for(const ln of lines){
        ctx.fillText(ln, HEADLINE_LEFT_PADDING, y);
        y += LINE_HEIGHT;
      }

      // Habilita download quando houver algo renderizado
      els.download.disabled = false;
    }

    // --- EVENTOS (inputs) ---

    // Preview automático digitando/mudando campos
    ['input','change'].forEach(evt => {
      els.destaque.addEventListener(evt, render);
      els.manchete.addEventListener(evt, render);
    });

    // Alteração da foto: gera URL, cria Image, centraliza e renderiza
    els.upload.addEventListener('change', async () => {
      if (els.upload.files && els.upload.files[0]) {
        revokeBgURL();
        bgURL = URL.createObjectURL(els.upload.files[0]);
        bgImg = await loadImage(bgURL);
        if (bgImg){
          centerAndClampBg(1080, 1350);
        }
        render();
      } else {
        revokeBgURL();
        bgImg = null;
        render();
      }
    });

    // Download apenas salva o canvas atual
    els.download.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'arte-manchete.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // Limpar
    els.clear.addEventListener('click', ()=>{
      els.destaque.value = 'ALERTA';
      els.manchete.value = '';
      els.upload.value = '';
      revokeBgURL();
      bgImg = null;
      // zera estado
      bgState.dw = bgState.dh = 0;
      bgState.x = bgState.y = 0;
      bgState.minX = bgState.maxX = 0;
      bgState.minY = bgState.maxY = 0;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      els.download.disabled = true;
      render(); // placeholder
    });

    // --- DRAG (Pointer Events) ---
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let imgStart = { x: 0, y: 0 };

    function toCanvasCoords(clientX, clientY){
      // converte coordenada de tela para coordenada "lógica" 1080x1350
      const rect = canvas.getBoundingClientRect();
      const W = 1080, H = 1350;
      const x = (clientX - rect.left) * (W / rect.width);
      const y = (clientY - rect.top)  * (H / rect.height);
      return { x, y };
    }

    canvas.addEventListener('pointerdown', (e) => {
      if(!bgImg) return;
      canvas.setPointerCapture(e.pointerId);
      isDragging = true;
      const p = toCanvasCoords(e.clientX, e.clientY);
      dragStart = p;
      imgStart = { x: bgState.x, y: bgState.y };
    });

    canvas.addEventListener('pointermove', (e) => {
      if(!isDragging || !bgImg) return;
      const p = toCanvasCoords(e.clientX, e.clientY);
      const dx = p.x - dragStart.x;
      const dy = p.y - dragStart.y;
      bgState.x = clamp(imgStart.x + dx, bgState.minX, bgState.maxX);
      bgState.y = clamp(imgStart.y + dy, bgState.minY, bgState.maxY);
      render();
    });

    function endDrag(e){
      if(!isDragging) return;
      isDragging = false;
      if (e && e.pointerId) {
        try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
      }
    }
    canvas.addEventListener('pointerup', endDrag);
    canvas.addEventListener('pointercancel', endDrag);
    canvas.addEventListener('pointerleave', endDrag);

    // Primeira render (placeholder)
    render();
  </script>
</body>
</html>
